// @lcpr-before-debug-begin

// @lcpr-before-debug-end

/*
 * @lc app=leetcode.cn id=924 lang=cpp
 * @lcpr version=30122
 *
 * [924] 尽量减少恶意软件的传播
 *
 * https://leetcode.cn/problems/minimize-malware-spread/description/
 *
 * algorithms
 * Hard (36.27%)
 * Likes:    102
 * Dislikes: 0
 * Total Accepted:    13.1K
 * Total Submissions: 34.7K
 * Testcase Example:  '[[1,1,0],[1,1,0],[0,0,1]]\n[0,1]'
 *
 * 给出了一个由 n 个节点组成的网络，用 n × n 个邻接矩阵图 graph 表示。在节点网络中，当 graph[i][j] = 1 时，表示节点 i
 * 能够直接连接到另一个节点 j。 
 *
 * 一些节点 initial
 * 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。
 *
 * 假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。
 *
 * 如果从 initial 中移除某一节点能够最小化 M(initial)， 返回该节点。如果有多个节点满足条件，就返回索引最小的节点。
 *
 * 请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后仍有可能因恶意软件传播而受到感染。
 *
 *
 *
 *
 *
 *
 * 示例 1：
 *
 * 输入：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
 * 输出：0
 *
 *
 * 示例 2：
 *
 * 输入：graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
 * 输出：0
 *
 *
 * 示例 3：
 *
 * 输入：graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
 * 输出：1
 *
 *
 *
 *
 * 提示：
 *
 *
 *
 * n == graph.length
 * n == graph[i].length
 * 2 <= n <= 300
 * graph[i][j] == 0 或 1.
 * graph[i][j] == graph[j][i]
 * graph[i][i] == 1
 * 1 <= initial.length <= n
 * 0 <= initial[i] <= n - 1
 * initial 中所有整数均不重复
 *
 *
 */

// @lcpr-template-start
using namespace std;
#include <algorithm>
#include <array>
#include <bitset>
#include <climits>
#include <deque>
#include <functional>
#include <iostream>
#include <list>
#include <queue>
#include <stack>
#include <tuple>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>
// @lcpr-template-end
// @lc code=start
// 并查集
class unionFind
{
public:
    vector<int> v_father;
    unionFind(int n)
    {
        for (int i = 0; i < n; i++)
        {
            v_father.push_back(i);
        }
    }
    int get(int i)
    {
        if (v_father[i] == i)
        {
            return i;
        }
        v_father[i] = get(v_father[i]);
        return v_father[i];
    }
    void set(int a, int b)
    {
        int fa = get(a);
        int fb = get(b);
        if (fa > fb)
        {
            v_father[fa] = fb;
        }
        else if (fb > fa)
        {
            v_father[fb] = fa;
        }
    }
};

class Solution
{
public:
    int minMalwareSpread(vector<vector<int>> &graph, vector<int> &initial)
    {
        // 并查集
        unionFind *uf = new unionFind(300);

        for (int ii = 0; ii < graph.size(); ii++)
        {
            for (int jj = ii + 1; jj < graph.size(); jj++)
            {
                if (graph[ii][jj] == 1)
                {
                    uf->set(ii, jj);
                }
            }
        }
        int result = 0;
        int last_end = 999999;
        unordered_map<int, int> init_map_fa;
        for (int i = 0; i < initial.size(); i++)
        {
            int cur_init = initial[i];
            init_map_fa[cur_init] = uf->get(cur_init);
        }
        // 检查答案
        sort(initial.begin(), initial.end());
        for (int i = 0; i < initial.size(); i++)
        {
            int delete_init = initial[i];
            unordered_set<int> other_fa;
            for (pair<int, int> pii : init_map_fa)
            {
                if (pii.first != delete_init)
                {

                    other_fa.insert(pii.second);
                }
            }
            int all_result = 0;
            for (int i = 0; i < graph.size(); i++)
            {
                int ii_fa = uf->get(i);
                if (other_fa.count(ii_fa) > 0)
                {
                    all_result++;
                }
            }
            if (all_result < last_end)
            {
                last_end = all_result;
                result = delete_init;
            }
        }
        return result;
    }
};
// @lc code=end

/*
// @lcpr case=start
// [[1,1,0],[1,1,0],[0,0,1]]\n[0,1]\n
// @lcpr case=end

// @lcpr case=start
// [[1,0,0],[0,1,0],[0,0,1]]\n[0,2]\n
// @lcpr case=end

// @lcpr case=start
// [[1,1,1],[1,1,1],[1,1,1]]\n[1,2]\n
// @lcpr case=end

// @lcpr case=start
// [[1,0,0,0,1,0,0,0,0,0,1],[0,1,0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,1,0,0,0],[0,1,0,1,0,1,0,0,0,0,0],[1,0,0,0,1,0,0,0,0,0,0],[0,0,0,1,0,1,0,0,1,1,0],[0,0,0,0,0,0,1,1,0,0,0],[0,0,1,0,0,0,1,1,0,0,0],[0,0,0,0,0,1,0,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0],[1,0,0,0,0,0,0,0,0,0,1]]\n[7,8,6,2,3]
// @lcpr case=end

 */
