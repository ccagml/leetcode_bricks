{"data":[{"name":"2023-02-15 16:28:20","id":1676449700927,"body":"Floyd\nclass Solution\n{\npublic:\n    int findTheCity(int n, vector<vector<int>> &edges, int distanceThreshold)\n    {\n        vector<vector<int>> vvi(n, vector<int>(n, 99999));\n        // vvi[x][y] = 最小 ?\n        for (int i = 0; i < n; i++)\n        {\n            vvi[i][i] = 0;\n        }\n        for (int i = 0; i < edges.size(); i++)\n        {\n            int a = edges[i][0];\n            int b = edges[i][1];\n            int v = edges[i][2];\n            vvi[a][b] = v;\n            vvi[b][a] = v;\n        }\n        // for (int x = 0; x < n; x++)\n        // {\n        //     for (int y = 0; y < n; y++)\n        //     {\n        //         for (int k = 0; k < n; k++)\n        //         {\n        //             int x_k_y = vvi[x][k] + vvi[k][y];\n        //             vvi[x][y] = min(vvi[x][y], x_k_y);\n        //             vvi[y][x] = min(vvi[y][x], x_k_y);\n        //         }\n        //     }\n        // }\n\n        for (int k = 0; k < n; ++k)\n        {\n            for (int i = 0; i < n; ++i)\n            {\n                for (int j = 0; j < n; ++j)\n                {\n                    int i_k_j = vvi[i][k] + vvi[k][j];\n                    vvi[i][j] = min(vvi[i][j], i_k_j);\n                    vvi[j][i] = min(vvi[j][i], i_k_j);\n                }\n            }\n        }\n\n        vector<unordered_set<int>> vus(n);\n        for (int x = 0; x < n; x++)\n        {\n            for (int y = 0; y < n; y++)\n            {\n                if (x == y)\n                {\n                    continue;\n                }\n                if (vvi[x][y] <= distanceThreshold)\n                {\n                    vus[x].insert(y);\n                }\n                if (vvi[y][x] <= distanceThreshold)\n                {\n                    vus[y].insert(x);\n                }\n            }\n        }\n        vector<pair<int, int>> vpii;\n        for (int i = 0; i < n; i++)\n        {\n            vpii.push_back({vus[i].size(), i});\n        }\n        sort(vpii.begin(), vpii.end(), [](const std::pair<int, int> &left, const std::pair<int, int> &right)\n             {\n                  // true使得left排前面\n                  if (left.first < right.first)\n                  {\n                      return true;\n                  }\n                  else if (left.first == right.first && left.second > right.second)\n                  {\n                      return true;\n                  }\n                  return false; });\n        // for (int i = 0; i < n; i++)\n        // {\n        //     std::cout << \"(\" << vpii[i].second << \",\" << vpii[i].first << \")|\";\n        // }\n\n        // if (vpii.size() > 2 && vpii[2].first == 38 && vpii[2].second == 38)\n        // {\n        //     return 38;\n        // }\n\n        return vpii[0].second;\n    }\n};"},{"name":"2023-02-15 17:16:49","id":1676452609403,"body":"\nAccepted\n54/54 cases passed (116 ms)\nYour runtime beats 11.44 % of cpp submissions\nYour memory usage beats 16.98 % of cpp submissions (15.1 MB)djikstra\nclass Solution\n{\npublic:\n    void djik(vector<vector<int>> &vvi, vector<int> &d, int start)\n    {\n        // 自定义比较函数pair//返回true使得第一个参数排后面\n        auto cmp_pair = [](const std::pair<int, int> &t1, const std::pair<int, int> &t2)\n        {\n            // true使得t1排后面?\n            if (t1.first > t2.first)\n            {\n                return true;\n            }\n            else if (t1.first == t2.first && t1.second < t2.second)\n            {\n                return true;\n            }\n            return false;\n        };\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, decltype(cmp_pair)> pair_pq(cmp_pair);\n        d[start] = 0;\n        pair_pq.push({d[start], start});\n        while (!pair_pq.empty())\n        {\n            pair<int, int> cur = pair_pq.top();\n            pair_pq.pop();\n            int cur_len = cur.first;\n            int cur_node = cur.second;\n\n            // 可以继续走\n            for (int i_node = 0; i_node < vvi.size(); i_node++)\n            {\n                if (i_node != cur_node)\n                {\n                    int cur_to_i = vvi[cur_node][i_node];\n                    if (d[i_node] > (cur_len + cur_to_i))\n                    {\n                        d[i_node] = (cur_len + cur_to_i);\n                        // 这里可以进\n                        pair_pq.push({d[i_node], i_node});\n                    }\n                }\n            }\n        }\n    }\n\n    int findTheCity(int n, vector<vector<int>> &edges, int distanceThreshold)\n    {\n        vector<vector<int>> vvi(n, vector<int>(n, 99999));\n        // vvi[x][y] = 最小 ?\n        for (int i = 0; i < n; i++)\n        {\n            vvi[i][i] = 0;\n        }\n        for (int i = 0; i < edges.size(); i++)\n        {\n            int a = edges[i][0];\n            int b = edges[i][1];\n            int v = edges[i][2];\n            vvi[a][b] = v;\n            vvi[b][a] = v;\n        }\n\n        // for (int k = 0; k < n; ++k)\n        // {\n        //     for (int i = 0; i < n; ++i)\n        //     {\n        //         for (int j = 0; j < n; ++j)\n        //         {\n        //             int i_k_j = vvi[i][k] + vvi[k][j];\n        //             vvi[i][j] = min(vvi[i][j], i_k_j);\n        //             vvi[j][i] = min(vvi[j][i], i_k_j);\n        //         }\n        //     }\n        // }\n\n        // 全路djiksra的做法\n        int max_count = 99999;\n        int id = -1;\n        for (int i = 0; i < n; i++)\n        {\n            vector<int> i_to_x(n, 99999);\n            djik(vvi, i_to_x, i);\n            int count = 0;\n            for (int j = 0; j < n; j++)\n            {\n                // std::cout << i << \"->\" << j << \"=\" << i_to_x[j] << \")\";\n                if (i != j && i_to_x[j] <= distanceThreshold)\n                {\n                    count++;\n                }\n            }\n            if ((count < max_count) || (count == max_count && i > id))\n            {\n                max_count = count;\n                id = i;\n            }\n        }\n        return id;\n    }\n};"},{"name":"2023-02-16 09:55:26","id":1676512526328,"body":"\nbellmanford\nAccepted\n54/54 cases passed (1528 ms)\nYour runtime beats 5.07 % of cpp submissions\nYour memory usage beats 30.8 % of cpp submissions (12.6 MB)\n\nclass Solution\n{\npublic:\n    void bellman_ford(vector<vector<pair<int, int>>> &vvpii, vector<int> &d, int node_num, int start)\n    {\n\n        // 初始化start的距离\n        for (pair<int, int> pp : vvpii[start])\n        {\n            d[pp.first] = pp.second;\n        }\n\n        // node_num - 1 次松弛\n        for (int i = 0; i < node_num - 1; i++)\n        {\n            // 松弛所有的边\n            for (int x = 0; x < vvpii.size(); x++)\n            {\n                for (int x_len = 0; x_len < vvpii[x].size(); x_len++)\n                {\n                    pair<int, int> pii = vvpii[x][x_len];\n                    int y = pii.first;\n                    int value = pii.second;\n                    if (d[y] > d[x] + value)\n                    {\n                        d[y] = d[x] + value;\n                    }\n                }\n            }\n        }\n    }\n\n    int findTheCity(int n, vector<vector<int>> &edges, int distanceThreshold)\n    {\n\n        vector<vector<pair<int, int>>> vvpii(n, vector<pair<int, int>>(0));\n\n        for (int i = 0; i < edges.size(); i++)\n        {\n            int x = edges[i][0];\n            int y = edges[i][1];\n            int value = edges[i][2];\n            vvpii[x].push_back({y, value});\n            vvpii[y].push_back({x, value});\n        }\n\n        int max_count = 99999;\n        int id = -1;\n        for (int i = 0; i < n; i++)\n        {\n            vector<int> len(n, 99999);\n            bellman_ford(vvpii, len, n, i);\n            int count = 0;\n            for (int j = 0; j < n; j++)\n            {\n                if (i != j && len[j] <= distanceThreshold)\n                {\n                    count++;\n                }\n            }\n            if ((count < max_count) || (count == max_count && i > id))\n            {\n                max_count = count;\n                id = i;\n            }\n        }\n        return id;\n    }\n};"},{"name":"2023-02-16 10:21:31","id":1676514091983,"body":"Accepted\n54/54 cases passed (56 ms)\nYour runtime beats 76.45 % of cpp submissions\nYour memory usage beats 11.23 % of cpp submissions (15.7 MB)\n\nclass Solution\n{\npublic:\n     // 带优先级队列的spfa\n    void spfa_bellman_pri_que(vector<vector<pair<int, int>>> &vvpii, vector<int> &d, int start)\n    {\n        auto cmp_pair = [](const std::pair<int, int> &t1, const std::pair<int, int> &t2)\n        {\n            // true使得t1排后面?\n            if (t1.first > t2.first)\n            {\n                return true;\n            }\n            else if (t1.first == t2.first && t1.second > t2.second)\n            {\n                return true;\n            }\n            return false;\n        };\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, decltype(cmp_pair)> pair_pq(cmp_pair);\n        // 初始化start的距离\n        for (pair<int, int> pp : vvpii[start])\n        {\n            d[pp.first] = pp.second;\n            pair_pq.push({pp.second, pp.first});\n        }\n        while (!pair_pq.empty())\n        {\n            pair<int, int> top = pair_pq.top();\n            pair_pq.pop();\n            int len = top.first;\n            int y_nodex = top.second;\n            // 出来已经有更短的了,说明这个没优势\n            if (len <= d[y_nodex])\n            {\n                for (pair<int, int> pp : vvpii[y_nodex])\n                {\n                    if (d[pp.first] > len + pp.second)\n                    {\n                        d[pp.first] = len + pp.second;\n                        pair_pq.push({d[pp.first], pp.first});\n                    }\n                }\n            }\n        }\n    }\n\n    int findTheCity(int n, vector<vector<int>> &edges, int distanceThreshold)\n    {\n\n        vector<vector<pair<int, int>>> vvpii(n, vector<pair<int, int>>(0));\n\n        for (int i = 0; i < edges.size(); i++)\n        {\n            int x = edges[i][0];\n            int y = edges[i][1];\n            int value = edges[i][2];\n            vvpii[x].push_back({y, value});\n            vvpii[y].push_back({x, value});\n        }\n\n        int max_count = 99999;\n        int id = -1;\n        for (int i = 0; i < n; i++)\n        {\n            vector<int> len(n, 99999);\n            spfa_bellman_pri_que(vvpii, len, i);\n            int count = 0;\n            for (int j = 0; j < n; j++)\n            {\n                if (i != j && len[j] <= distanceThreshold)\n                {\n                    count++;\n                    // std::cout << \"(\" << i << \"to\" << j << \"=\" << count << \")\";\n                }\n            }\n            if ((count < max_count) || (count == max_count && i > id))\n            {\n                max_count = count;\n                id = i;\n            }\n        }\n        return id;\n    }\n};\n"},{"name":"2024-01-06 15:31:44","id":1704526304961,"body":"Accepted\n54/54 cases passed (2028 ms)\nYour runtime beats 5.31 % of cpp submissions\nYour memory usage beats 10.84 % of cpp submissions (17.6 MB)\n耗时 1:37:26\n// 看不出为什么过不去\n//  因为保存的值 uiusi_len[start_flag][pii_next.first] 不对\n//  进入 pii_next.first 应当保存  cur_len - pii_next.second\nclass Solution\n{\npublic:\n    void check_n(int start_flag, int cur_n, int cur_len, int deep)\n    {\n        if (cur_len <= 0)\n        {\n            return;\n        }\n        for (pair<int, int> pii_next : uiuii[cur_n])\n        {\n            // 还没到过\n            if ((uiusi[start_flag].count(pii_next.first) == 0 || (uiusi_len[start_flag].count(pii_next.first) > 0 && uiusi_len[start_flag][pii_next.first] < (cur_len - pii_next.second))) && cur_len >= pii_next.second && pii_next.first != start_flag)\n            {\n                uiusi_len[start_flag][pii_next.first] = cur_len - pii_next.second;\n                uiusi[start_flag].insert(pii_next.first);\n                check_n(start_flag, pii_next.first, cur_len - pii_next.second, deep + 1);\n            }\n        }\n    }\n    unordered_map<int, unordered_set<int>> uiusi;\n    unordered_map<int, unordered_map<int, int>> uiusi_len;\n\n    unordered_map<int, unordered_map<int, int>> uiuii;\n    int findTheCity(int n, vector<vector<int>> &edges, int distanceThreshold)\n    {\n        // dfs?\n        for (int j = 0; j < edges.size(); j++)\n        {\n            int a = edges[j][0];\n            int b = edges[j][1];\n            int len = edges[j][2];\n            if (len <= distanceThreshold)\n            {\n                uiuii[a][b] = len;\n                uiuii[b][a] = len;\n            }\n        }\n\n        for (int j = 0; j < n; j++)\n        {\n            check_n(j, j, distanceThreshold, 0);\n        }\n\n        int result = 0;\n        int cur_cnt = 99999;\n\n        for (int j = 0; j < n; j++)\n        {\n            if (uiusi[j].size() <= cur_cnt)\n            {\n                cur_cnt = uiusi[j].size();\n                result = j;\n            }\n        }\n        return result;\n    }\n};\n"}]}