{"data":[{"name":"2023-07-18 11:07:13","id":1689649633827,"body":"线段树 超时\nint temp_max = 99999999;\n\nclass segmentTree\n{\nprivate:\n    class segmentTreeNode\n    {\n    public:\n        segmentTreeNode(int l, int r)\n        {\n            left = l;\n            right = r;\n            val = 0;\n            temp_add = 0;\n            min_v = temp_max;\n            left_son = nullptr;\n            right_son = nullptr;\n            push_down_flag = true;\n        }\n        int id;\n        int left;\n        int right;\n        long long min_v = 0;\n        bool push_down_flag;\n        long long val;\n        long long temp_add;\n        segmentTreeNode *left_son;\n        segmentTreeNode *right_son;\n    };\n\n    int all_left, all_right;\n\n    void modify(segmentTreeNode *cur_node, int cur_l, int cur_r, int need_L, int need_R, long long new_v)\n    {\n        cur_node->push_down_flag = true;\n        //  cur_l   need_L  need_R  cur_r\n        //  范围外\n        if (cur_l > need_R || cur_r < need_L)\n        {\n            return;\n        }\n\n        // 全包含了,不往下递推\n        if (need_L <= cur_l && cur_r <= need_R && cur_node->left_son == nullptr && cur_node->right_son == nullptr)\n        {\n            cur_node->min_v = min(new_v, cur_node->min_v);\n\n            // 2 3-6 10  /  3  -  6 == 5\n            return;\n        }\n        int old_min_v = cur_node->min_v;\n        cur_node->min_v = temp_max;\n        // 继续下推\n        int mid = (cur_l + cur_r) >> 1;\n        if (cur_node->left_son == nullptr)\n        {\n            cur_node->left_son = new segmentTreeNode(cur_l, mid);\n        }\n        if (cur_node->right_son == nullptr)\n        {\n            cur_node->right_son = new segmentTreeNode((mid + 1), cur_r);\n        }\n        if (old_min_v != temp_max)\n        {\n            modify(cur_node->left_son, cur_l, mid, cur_l, cur_r, old_min_v);\n            modify(cur_node->right_son, mid + 1, cur_r, cur_l, cur_r, old_min_v);\n        }\n        modify(cur_node->left_son, cur_l, mid, need_L, need_R, new_v);\n        modify(cur_node->right_son, mid + 1, cur_r, need_L, need_R, new_v);\n    }\n\n    segmentTreeNode *root;\n    long long query_min(segmentTreeNode *cur_node, int cur_l, int cur_r, int NEED_L, int NEED_R)\n    {\n        if (cur_node == nullptr)\n        {\n            return temp_max;\n        }\n        if (cur_l > NEED_R || cur_r < NEED_L)\n        {\n            return temp_max;\n        }\n\n        if (cur_node->left_son == nullptr && cur_node->right_son == nullptr && cur_l <= NEED_L && NEED_R <= cur_r)\n        {\n            return cur_node->min_v;\n        }\n        if (NEED_L <= cur_l && cur_r <= NEED_R)\n            return cur_node->min_v;\n        // pushdown(cur_node, 0);\n        long mid = (cur_l + cur_r) >> 1;\n        return min(query_min(cur_node->left_son, cur_l, mid, NEED_L, NEED_R), query_min(cur_node->right_son, mid + 1, cur_r, NEED_L, NEED_R));\n    }\n\npublic:\n    segmentTree(int left, int right)\n    {\n\n        root = new segmentTreeNode(left, right);\n        all_left = left;\n        all_right = right;\n    }\n\n    void modify(int l, int r, long long new_v)\n    {\n        modify(root, all_left, all_right, l, r, new_v);\n    }\n    int query(int l, int r)\n    {\n        return query_min(root, all_left, all_right, l, r);\n    }\n};\n\nclass Solution\n{\npublic:\n    vector<int> minInterval(vector<vector<int>> &intervals, vector<int> &queries)\n    {\n        segmentTree *st = new segmentTree(1, 10000002);\n        for (int i = 0; i < intervals.size(); i++)\n        {\n            int a = intervals[i][0];\n            int b = intervals[i][1];\n            int c = b - a + 1;\n            st->modify(a, b, c);\n        }\n        vector<int> result;\n        for (int q : queries)\n        {\n            int temp_q = st->query(q, q);\n            result.push_back(((temp_q == temp_max) ? -1 : temp_q));\n        }\n        return result;\n    }\n};"},{"name":"2023-07-18 11:46:54","id":1689652014191,"body":"Accepted\n42/42 cases passed (556 ms)\nYour runtime beats 60.23 % of cpp submissions\nYour memory usage beats 44.32 % of cpp submissions (130.6 MB)\n耗时 0:27:14\nclass Solution\n{\npublic:\n    vector<int> minInterval(vector<vector<int>> &intervals, vector<int> &queries)\n    {\n\n        // 自定义比较函数pair//返回true使得第一个参数排后面\n        auto cmp_pair = [](const std::pair<int, int> &t1, const std::pair<int, int> &t2)\n        {\n            // true使得t1排后面?\n            if (t1.first > t2.first)\n            {\n                return true;\n            }\n            else if (t1.first == t2.first && t1.second > t2.second)\n            {\n                return true;\n            }\n            return false;\n        };\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, decltype(cmp_pair)> pair_pq(cmp_pair);\n        unordered_set<int> usi;\n        vector<int> vi;\n        for (int q : queries)\n        {\n            usi.insert(q);\n        }\n        for (int q : usi)\n        {\n            vi.push_back(q);\n        }\n        sort(vi.begin(), vi.end());\n        sort(intervals.begin(), intervals.end());\n        int vii = 0;\n        int ii = 0;\n        unordered_map<int, int> umii;\n        while (vii < vi.size())\n        {\n            int need_check = vi[vii];\n            while (ii < intervals.size())\n            {\n                int a = intervals[ii][0];\n                int b = intervals[ii][1];\n                int len = b - a + 1;\n                if (a <= need_check)\n                {\n                    pair_pq.push({len, a});\n                    ii++;\n                }\n                else\n                {\n                    break;\n                }\n            }\n\n            // 过滤掉无效区间\n            while (pair_pq.size() > 0)\n            {\n                pair<int, int> top = pair_pq.top();\n                int a = top.second;\n                int c = top.first;\n                int b = c + a - 1;\n                if (b < need_check)\n                {\n                    pair_pq.pop();\n                }\n                else\n                {\n                    break;\n                }\n            }\n            // 结果\n            if (pair_pq.size() == 0)\n            {\n                umii[need_check] = -1;\n            }\n            else\n            {\n                pair<int, int> top = pair_pq.top();\n                int a = top.second;\n                int c = top.first;\n                int b = c + a - 1;\n                if (a > need_check)\n                {\n                    umii[need_check] = -1;\n                }\n                else\n                {\n                    umii[need_check] = c;\n                }\n            }\n            vii++;\n        }\n        vector<int> result;\n        for (int q : queries)\n        {\n            result.push_back(umii[q]);\n        }\n        return result;\n    }\n};"}]}