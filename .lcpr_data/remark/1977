{"data":[{"name":"2023-07-18 11:07:13","id":1689649633827,"body":"线段树 超时\nint temp_max = 99999999;\n\nclass segmentTree\n{\nprivate:\n    class segmentTreeNode\n    {\n    public:\n        segmentTreeNode(int l, int r)\n        {\n            left = l;\n            right = r;\n            val = 0;\n            temp_add = 0;\n            min_v = temp_max;\n            left_son = nullptr;\n            right_son = nullptr;\n            push_down_flag = true;\n        }\n        int id;\n        int left;\n        int right;\n        long long min_v = 0;\n        bool push_down_flag;\n        long long val;\n        long long temp_add;\n        segmentTreeNode *left_son;\n        segmentTreeNode *right_son;\n    };\n\n    int all_left, all_right;\n\n    void modify(segmentTreeNode *cur_node, int cur_l, int cur_r, int need_L, int need_R, long long new_v)\n    {\n        cur_node->push_down_flag = true;\n        //  cur_l   need_L  need_R  cur_r\n        //  范围外\n        if (cur_l > need_R || cur_r < need_L)\n        {\n            return;\n        }\n\n        // 全包含了,不往下递推\n        if (need_L <= cur_l && cur_r <= need_R && cur_node->left_son == nullptr && cur_node->right_son == nullptr)\n        {\n            cur_node->min_v = min(new_v, cur_node->min_v);\n\n            // 2 3-6 10  /  3  -  6 == 5\n            return;\n        }\n        int old_min_v = cur_node->min_v;\n        cur_node->min_v = temp_max;\n        // 继续下推\n        int mid = (cur_l + cur_r) >> 1;\n        if (cur_node->left_son == nullptr)\n        {\n            cur_node->left_son = new segmentTreeNode(cur_l, mid);\n        }\n        if (cur_node->right_son == nullptr)\n        {\n            cur_node->right_son = new segmentTreeNode((mid + 1), cur_r);\n        }\n        if (old_min_v != temp_max)\n        {\n            modify(cur_node->left_son, cur_l, mid, cur_l, cur_r, old_min_v);\n            modify(cur_node->right_son, mid + 1, cur_r, cur_l, cur_r, old_min_v);\n        }\n        modify(cur_node->left_son, cur_l, mid, need_L, need_R, new_v);\n        modify(cur_node->right_son, mid + 1, cur_r, need_L, need_R, new_v);\n    }\n\n    segmentTreeNode *root;\n    long long query_min(segmentTreeNode *cur_node, int cur_l, int cur_r, int NEED_L, int NEED_R)\n    {\n        if (cur_node == nullptr)\n        {\n            return temp_max;\n        }\n        if (cur_l > NEED_R || cur_r < NEED_L)\n        {\n            return temp_max;\n        }\n\n        if (cur_node->left_son == nullptr && cur_node->right_son == nullptr && cur_l <= NEED_L && NEED_R <= cur_r)\n        {\n            return cur_node->min_v;\n        }\n        if (NEED_L <= cur_l && cur_r <= NEED_R)\n            return cur_node->min_v;\n        // pushdown(cur_node, 0);\n        long mid = (cur_l + cur_r) >> 1;\n        return min(query_min(cur_node->left_son, cur_l, mid, NEED_L, NEED_R), query_min(cur_node->right_son, mid + 1, cur_r, NEED_L, NEED_R));\n    }\n\npublic:\n    segmentTree(int left, int right)\n    {\n\n        root = new segmentTreeNode(left, right);\n        all_left = left;\n        all_right = right;\n    }\n\n    void modify(int l, int r, long long new_v)\n    {\n        modify(root, all_left, all_right, l, r, new_v);\n    }\n    int query(int l, int r)\n    {\n        return query_min(root, all_left, all_right, l, r);\n    }\n};\n\nclass Solution\n{\npublic:\n    vector<int> minInterval(vector<vector<int>> &intervals, vector<int> &queries)\n    {\n        segmentTree *st = new segmentTree(1, 10000002);\n        for (int i = 0; i < intervals.size(); i++)\n        {\n            int a = intervals[i][0];\n            int b = intervals[i][1];\n            int c = b - a + 1;\n            st->modify(a, b, c);\n        }\n        vector<int> result;\n        for (int q : queries)\n        {\n            int temp_q = st->query(q, q);\n            result.push_back(((temp_q == temp_max) ? -1 : temp_q));\n        }\n        return result;\n    }\n};"}]}